# Counting inversions 

    Programming Problem 3.5: Counting inversions

### Sanity check: 
First, check that your algorithms counts 0 inversions for a sorted array, and n(n-1) รท 2 inversions for a reverse sorted array (e.g., 28 inversions for [ 8 7 6 5 4 3 2 1 ]).
    
### Test case: 
This file (http://www.algorithmsilluminated.org/datasets/problem3.5test.txt) contains 10 integers, representing a 10-element array. Your program should count 28 inversions in this array.
        
### Challenge data set: 
This file (http://www.algorithmsilluminated.org/datasets/problem3.5.txt) contains all of the integers between 1 and 100,000 (inclusive) in some order, with no integer repeated.   
The ith row of the file indicates the ith entry of an array. How many inversions does this array have?  

Obviously, to get the most out of this assignment, you should implement the fast divide-and-conquer algorithm from Section 3.2, rather than brute-force search.) 

ref. Coursera/Stanford Algorithms [Divide and Conquer, Sorting and Searching, and Randomized Algorithms](https://www.coursera.org/learn/algorithms-divide-conquer)

## Version compatibility
This exercise has been tested on Julia versions >=1.0.

## Submitting Incomplete Solutions
#NA
